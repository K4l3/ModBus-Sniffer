int wrposs = 0;       //Possition to write the next byte to 
int rposs = 0;        //Possition to read from - must be x amount of spaces behind wrposs
int data[];           //Arry to store bytes in
int testreg = 0;      //Test location for data to be sent to
bool messread = false; //message beign checked and recieved.
int messlng = 0;      //used to count bytes till ennd of massage - allow pull full message from buffer
bool cmpmess = false; //used to indicate full message pulled from buffer. 
int devadd = 0;       //device address
int reglng = 0;       //device register length in number of bytes
uint64_t regval = 0 ;       //register value


void setup() {
  Serial.begin(115200);
  Serial1.begin(115200);  

}

void loop() {
  //read from buffer to array, check if data good. either moves to next step or steps to next reading
  if (Serial1.available() > 0) {
    data[wrposs] = Serial1.read();
    wrposs++;
    
    if (messread == false && wrposs > rposs + 9){
      //read possition 8byte behind wrposs. Message come through, check replay using correct digits, check length expected and parse. if not moce 1 space up and try again. add timeout function
      if (data[rposs] == data[wrposs - 1] && data[rposs] == data[wrposs - 1]) {
        messread = true;
        devadd = data[rposs];
        Serial.println("Device Address: " + devadd);
        reglng = data[rposs + 9];     //change to read byte count from reply - check
        Serial.println("Register length: " + reglng)
      }
      else{
        data[rposs] = 0;  //clear array possition
        rposs++;
      }
    }
  }

  //allow to read data still incoming based on lengh. calculate with reglng from roposs. once done shift rposs up. DOuble check counts in data to make sure moving to correct possition
  while (messread == true){         //keep in data collection loop, kick out once data is recieved.
    if (Serial1.available() >0){    //read to data array and count possition
      data[wrposs] = Serial1.read();
      wrposs++;
    }
    
    if (wrposs == rposs + 9 + reglng;){
      if (reglng = 1) {regval = ((data[reglng]));}  //write multiple possitions from data array to regval - check possitining 
      if (reglng = 2) {regval = ((data[reglng] << 8) + (data[reglng + 1]));}
      if (reglng = 3) {regval = ((data[reglng] << 16) + (data[reglng + 1] << 8) + (data[reglng + 2]));}
      if (reglng = 4) {regval = ((data[reglng] << 24) +(data[reglng +1 ] << 16) + (data[reglng + 2] << 8) + (data[reglng + 3]));}
      Serial.println("Register value: " + regval);
    }

    if (wrposs == rposs + 13 + reglng;){       //might have to plus one to get next buffer reading but might cause issues with the while loop.
      rposs = rposs + 13 + reglng;            //shift possition up (still add data clear) 
      messread = false;                       //excite while loop
    }
  }
}
